/**
 * # Firestore Security Rules: Babylon Block Portal
 *
 * ## Core Philosophy
 * This ruleset enforces a strict security model based on user ownership and role-based access control (RBAC). The primary goal is to ensure that users can only access and manage their own data, while designated administrators have broader permissions to manage public application data like raffles. The rules are designed to be efficient and secure, avoiding costly or insecure patterns.
 *
 * ## Data Structure
 * The data is organized into two main categories:
 * 1.  **User-Scoped Data**: All data private to a user (profile, spins, transactions) is stored in subcollections under `/users/{userId}`. This structure allows for simple and highly performant security rules based on the document path.
 * 2.  **Public & Shared Data**: Publicly readable data like raffles are stored in top-level collections. Access to these collections is controlled globally. Administrator status is managed through a dedicated `/roles_admin` collection, which serves as a fast lookup for role checks.
 *
 * ## Key Security Decisions
 * - **Default Deny**: All paths are closed by default. Access must be explicitly granted.
 * - **Strict Ownership**: Users have full control over their own data tree (`/users/{userId}/...`) but have no access to other users' data. User listing is explicitly disallowed to protect privacy.
 * - **Admin Roles via Lookup**: Administrator privileges are granted by the existence of a document in the `/roles_admin/{userId}` collection. This is a secure and scalable pattern for managing roles.
 * - **Immutable History**: Game and financial history, such as lucky wheel spins and transactions, are immutable. Once created, they cannot be updated or deleted by users to ensure data integrity.
 *
 * ## Denormalization for Authorization
 * To create simpler and more performant rules, we denormalize the `userId` into documents where path-based ownership is not possible. For example, a `RaffleEntry` document under `/raffles/{raffleId}/raffleEntries/{entryId}` contains a `userId` field. This allows a security rule to validate that a user is creating an entry for themselves without needing to perform a slow and costly `get()` on another document.
 *
 * ## Structural Segregation
 * The ruleset segregates private and public data into different collections. User-specific, private data (like `transactions`) resides in user subcollections. Publicly readable data (like `raffles`) resides in a top-level collection. This separation ensures that `list` operations are inherently secure and efficient.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // =================================
    // Helper Functions
    // =================================

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user is the owner of a document,
     * based on a userId provided from a path segment.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the authenticated user is the owner of an EXISTING document.
     * Crucial for secure update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Checks if the current user has administrative privileges by verifying
     * the existence of a corresponding document in the roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Checks if the authenticated user owns a specific raffle entry.
     * This relies on a denormalized `userId` field within the entry document.
     */
    function isEntryOwner() {
      return isSignedIn() && resource != null && resource.data.userId == request.auth.uid;
    }

    // =================================
    // User Data Rules
    // =================================

    /**
     * @description Manages user profile documents. A user can create their own profile
     *              and can read/update it, but cannot delete it or see other profiles.
     * @path /users/{userId}
     * @allow (create) A new user ('user123') creating their own document at `/users/user123`.
     * @deny (get) User 'user123' trying to read the profile of 'user456'.
     * @deny (list) Any user trying to list all documents in the `/users` collection.
     * @principle Enforces self-creation and strict document ownership for user profiles.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if false;
    }

    /**
     * @description Manages a user's lucky wheel spin history. This data is private
     *              and owned entirely by the user. History is immutable.
     * @path /users/{userId}/luckyWheelSpins/{spinId}
     * @allow (create) User 'user123' creating a new spin document under `/users/user123/...`.
     * @deny (get) User 'user456' trying to read a spin document belonging to 'user123'.
     * @principle Restricts access to a user's own data tree (path-based ownership).
     */
    match /users/{userId}/luckyWheelSpins/{spinId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages a user's transaction history. This data is private,
     *              owned by the user, and is immutable.
     * @path /users/{userId}/transactions/{transactionId}
     * @allow (list) User 'user123' reading their own transaction history at `/users/user123/transactions`.
     * @deny (create) User 'user456' trying to create a transaction for 'user123'.
     * @principle Restricts access to a user's own data tree (path-based ownership).
     */
    match /users/{userId}/transactions/{transactionId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if false;
      allow delete: if false;
    }

    // =================================
    // Role & Admin Rules
    // =================================

    /**
     * @description Manages administrator roles. Existence of a document in this collection
     *              grants admin privileges. Only other admins can manage this collection.
     * @path /roles_admin/{userId}
     * @allow (create) An existing admin user creating an admin document for 'user456' at `/roles_admin/user456`.
     * @deny (get) A non-admin user trying to read any document in this collection.
     * @principle Restricts all access to administrators, securing the role management system.
     */
    match /roles_admin/{userId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    // =================================
    // Public Game Data Rules
    // =================================

    /**
     * @description Manages public raffle events. These are readable by anyone,
     *              but can only be created, updated, or deleted by an administrator.
     * @path /raffles/{raffleId}
     * @allow (get) Any user, signed in or not, reading a specific raffle.
     * @deny (create) A non-admin user trying to create a new raffle.
     * @principle Allows public read access while restricting all write access to administrators.
     */
    match /raffles/{raffleId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Manages user entries into a specific raffle.
     * @path /raffles/{raffleId}/raffleEntries/{entryId}
     * @allow (create) User 'user123' creating a new entry with `{ userId: 'user123', ... }`.
     * @deny (list) A non-admin trying to list all entries in a raffle.
     * @deny (update) User 'user123' trying to change their raffle entry after submitting it.
     * @principle Allows users to create their own entries but prevents them from viewing or modifying others' entries.
     */
    match /raffles/{raffleId}/raffleEntries/{entryId} {
      allow get: if isEntryOwner() || isAdmin();
      allow list: if isAdmin();
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }
  }
}